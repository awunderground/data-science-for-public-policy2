[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science for Public Policy Part II",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "01_advanced-quarto.html#sec-review",
    "href": "01_advanced-quarto.html#sec-review",
    "title": "1  Advanced Quarto",
    "section": "1.1 Review",
    "text": "1.1 Review\n\n1.1.1 Motivation\nThere are many problems worth avoiding in an analysis:\n\nCopying-and-pasting, transposing, and manual repetition\nRunning code out-of-order\nMaintaining parallel documents like a script for analysis and a doc for narrative\nCode written for computers that is tough to parse by humans\n\nNot convinced? Maybe we just want to make cool stuff like websites, blogs, books, and slide decks.\nQuarto, a literate statistical programming framework for R, Python, and Julia helps us solve many of these problems. Quarto uses\n\nplain text files ending in .qmd that are similar to .R and .Rmd files\nlibrary(knitr)\npandoc1\n\nQuarto uses library(knitr) and pandoc to convert plain text .qmd documents into rich output documents like these class notes. The “Render” button appears in RStudio with a .qmd file is open in the editor window.\nClicking the “Render” button begins the process of rendering .qmd files.\n\n\n\n\n\n\n\n\n\nWhen the button is clicked, Quarto calls library(knitr) and renders .qmd (Quarto files) into .md (Markdown files), which Pandoc then converts into any specified output type. Quarto and library(knitr) don’t need to be explicitly loaded as the entire process is handled by clicking the “Render” button in RStudio.\n\n\n\n\n\n\n\n\n\nSource: Quarto website\nQuarto, library(knitr), and Pandoc are all installed with RStudio. You will need to install a LaTeX distribution to render PDFs. We recommend library(tinytex) as a LaTeX distribution (installation instructions).\n\n\n\n\n\n\nExercise 1\n\n\n\n\nClick the new script button in RStudio and add a “Quarto Document”.\nGive the document a name, an author, and ensure that HTML is selected.\nSave the document as “hello-quarto.qmd”.\nClick “Render”.\n\n\n\nQuarto has three main ingredients:\n\nYAML header\nMarkdown text\nCode chunks\n\n\n\n1.1.2 (1) YAML Header\nYAML stands for “yet another markup language”. The YAML header contains meta information about the document including output type, document settings, and parameters that can be passed to the document. The YAML header starts with --- and ends with ---.\nHere is the simplest YAML header for a PDF document:\n---\nformat: pdf\n---\nYAML headers can contain many output specific settings. This YAML header creates an HTML document with code folding and a floating table of contents:\n---\nformat: \n  html:\n    embed-resources: true\n    code-fold: true\n    toc: true\n---  \nParameters can be specified as follows\n---\nformat: pdf\nparams:\n  state: \"Virginia\"\n---\nNow state can be referred to anywhere in R code as params$state. Parameters are useful for a couple of reasons:\n\nWe can clearly change key values for a Quarto document in the YAML header.\nWe can create a template and programmatically iterate the template over a set of values with the quarto_render() function and library(purrr). This blog outlines the idea. The Mobility Metrics Data Tables and SLFI State Fiscal Briefs are key examples of this workflow.\n\n\n\n\n\n\n\nWarning\n\n\n\nUnlike R Markdown, images and other content are not embedded in .html from Quarto by default. Be sure to include embed-resources: true in YAML headers to embed content and make documents easier to share.\nSuppose we embed an image called image.png in a Quarto document called example.qmd, which, when rendered, creates example.html. If we don’t include embed-resources: true, then we will need to share image.png and example.html to see the embedded image. This is also true for other files like .css.\n\n\n\n\n1.1.3 (2) Markdown text\nMarkdown is a shortcut for HyperText Markup Language (HTML). Essentially, simple meta characters corresponding to formatting are added to plain text.\nTitles and subtitltes\n------------------------------------------------------------\n\n# Title 1\n\n## Title 2\n\n### Title 3\n\n\nText formatting \n------------------------------------------------------------\n\n*italic*  \n\n**bold**   \n\n`code`\n\nLists\n------------------------------------------------------------\n\n* Bulleted list item 1\n* Item 2\n  * Item 2a\n  * Item 2b\n\n1. Item 1\n2. Item 2\n\nLinks and images\n------------------------------------------------------------\n\n[text](http://link.com)\n\n![Penguins](images/penguins.png)\n\n\n1.1.4 (3) Code chunks\n\n\n\n\n\nMore frequently, code is added in code chunks:\n\n```{r}\n2 + 2\n```\n\n[1] 4\n\n\nThe first argument inline or in a code chunk is the language engine. Most commonly, this will just be a lower case r. knitr allows for many different language engines:\n\nR\nJulia\nPython\nSQL\nBash\nRcpp\nStan\nJavascript\nCSS\n\nQuarto has a rich set of options that go inside of the chunks and control the behavior of Quarto.\n\n```{r}\n#| label: important-calculation\n#| eval: false\n\n2 + 2\n```\n\nIn this case, eval makes the code not run. Other chunk-specific settings can be added inside the brackets. Here2 are the most important options:\n\n\n\nOption\nEffect\n\n\n\n\necho: false\nHides code in output\n\n\neval: false\nTurns off evaluation\n\n\noutput: false\nHides code output\n\n\nwarning: false\nTurns off warnings\n\n\nmessage: false\nTurns off messages\n\n\nfig-height: 8\nChanges figure width in inches3\n\n\nfig-width: 8\nChanges figure height in inches4\n\n\n\nYou can see the quarto defaults for figure dimensions by format here.\nDefault settings for the entire document can be changed in the YAML header with the execute option:\nexecute:\n  warning: false\n\n\n\n\n\n\nExercise 2\n\n\n\n\nAdd date: today to your YAML header after title. This will update every time the document is rendered.\nCopy the Markdown table from this table generator and add it to your .qmd document.\nCreate a scatter plot of the cars data with library(ggplot2). Adjust the figure width and height using options within the chunk.\nClick “Render”.\n\n\n\n\n\n1.1.5 Organizing a Quarto Document\nIt is important to clearly organize a Quarto document and the constellation of files that typically support an analysis.\n\nAlways use .Rproj files.\nUse sub-directories to sort images, .css, data.\n\nLater, we will learn how to use library(here) to effectively organize sub-directories."
  },
  {
    "objectID": "01_advanced-quarto.html#math-notation",
    "href": "01_advanced-quarto.html#math-notation",
    "title": "1  Advanced Quarto",
    "section": "1.2 Math Notation",
    "text": "1.2 Math Notation\nThis course uses probability and statistics. Occasionally, we want to easily communicate with mathematical notation. For example, it may be convenient to type that \\(X\\) is a random variable that follows a standard normal distribution (mean = 0 and standard deviation = 1).\n\\[X \\sim N(\\mu = 0, \\sigma = 1)\\]\n\n1.2.1 Math Mode\nUse $ to start and stop in-line math notation and $$ to start multi-line math notation. Math notation uses LaTeX’s syntax for mathematical notation.\nHere’s an example with in-line math:\nConsider a binomially distributed random variable, $X \\sim binom(n, p)$. \nConsider a binomially distributed random variable, \\(X \\sim binom(n, p)\\).\nHere’s an example with a chunk of math:\n$$\nP(X = x) = {n \\choose x} p ^ x (1 - p) ^ {n - x}\n$${#eq-binomial}\n\\[\nP(X = x) = {n \\choose x} p ^ x (1 - p) ^ {n - x}\n\\tag{1.1}\\]\n\n\n1.2.2 Important Syntax\nMath mode recognizes basic math symbols available on your keyboard including +, -, *, /, &gt;, &lt;, (, and ).\nMath mode contains all greek letters. For example, \\alpha (\\(\\alpha\\)) and \\beta (\\(\\beta\\)).\n\n\nTable 1.1: My Caption\n\n\nLaTeX\nSymbol\n\n\n\n\n\\alpha\n\\(\\alpha\\)\n\n\n\\beta\n\\(\\beta\\)\n\n\n\\gamma\n\\(\\gamma\\)\n\n\n\\Delta\n\\(\\Delta\\)\n\n\n\\epsilon\n\\(\\epsilon\\)\n\n\n\\theta\n\\(\\theta\\)\n\n\n\\pi\n\\(\\pi\\)\n\n\n\\sigma\n\\(\\sigma\\)\n\n\n\\chi\n\\(\\chi\\)\n\n\n\n\nMath mode also recognizes \\(\\log(x)\\) (\\log(x)) and \\(\\sqrt{x}\\) (\\sqrt{x}).\nSuperscripts (^) are important for exponentiation and subscripts (_) are important for adding indices. y = x ^ 2 renders as \\(y = x ^ 2\\) and x_1, x_2, x_3 renders as \\(x_1, x_2, x_3\\). Brackets are useful for multi-character superscripts and subscripts like \\(s_{11}\\) (s_{11}).\nIt is useful to add symbols to letters. For example, \\bar{x} is useful for sample means (\\(\\bar{x}\\)), \\hat{y} is useful for predicted values (\\(\\hat{y}\\)), and \\vec{\\beta} is useful for vectors of coefficients (\\(\\vec{\\beta}\\)).\nMath mode supports fractions with \\frac{x}{y} (\\(\\frac{x}{y}\\)), big parentheses with \\left(\\right) (\\(\\left(\\right)\\)), and brackets with \\left[\\right] (\\(\\left[\\right]\\)).\nMath mode has a symbol for summation. Let’s combine it with bars, fractions, subscripts, and superscipts to show sample mean \\bar{x} = \\frac{1}{n}\\sum_i^n x_i, which looks like \\(\\bar{x} = \\frac{1}{n}\\sum_i^n x_i\\).\n\\sim is how to add the tilde for distributed as. For example, X \\sim N(\\mu = 0, \\sigma = 1) shows the normal distribution \\(X \\sim N(\\mu = 0, \\sigma = 1)\\).\nMatrices are are a little bit more work in math mode. Consider the follow variance-covariance matrix:\n\\begin{bmatrix}\ns_{11}^2 & s_{12}\\\\\ns_{21} & s_{22}^2\n\\end{bmatrix}\n\\[\n\\begin{bmatrix}\ns_{11}^2 & s_{12}\\\\\ns_{21} & s_{22}^2\n\\end{bmatrix}\n\\]\nThis guide provides and exhaustive look at math options in Quarto.\n\n\n\n\n\n\nWarning\n\n\n\nMath mode is finicky! Small errors like mismatched parentheses or superscript and subscript errors will cause Quarto documents to fail to render. Write math carefully and render early and often.\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\n\nUse math mode to type out the equation for root mean square error (RMSE).\nDo you divide by n or n - 1?"
  },
  {
    "objectID": "01_advanced-quarto.html#cross-references",
    "href": "01_advanced-quarto.html#cross-references",
    "title": "1  Advanced Quarto",
    "section": "1.3 Cross References",
    "text": "1.3 Cross References\nCross references are useful for organizing documents that include sections, figures, tables, and equations. Cross references create hyperlinks within documents that jump to the locations of these elements. Linking sections, figures, tables, or equations helps readers navigate the document.\nCross references also automatically number the referenced elements. This means that if there are two tables (ie. Table 1 and Table 2) and a table is added between the two tables, all of the table numbers and references to the tables will automatically update.\nCross references require two bits of code within a Quarto document:\n\nA label associated with the section, figure, table, or equation.\nA reference to the labelled section, figure, table, or equation.\n\nLabels are written in brackets or as arguments in code chunks, and begin with the the type object being linked. References begin with @ followed by the label of object being linked.\n\n1.3.1 Sections\nLinking sections helps readers navigate between sections. Use brackets to label sections after headers and always begin labels with sec-. Then you can reference that section with @sec-.\n## Review {sec-review}\n\nSee @sec-review if you are totally lost.\nThe cross references shows up like this: See Section 1.1 if you are totally lost.\nIt can be helpful to turn on section numbering with number-sections: true in the YAML header. Additionally, Markdown has a native method for linking between sections.\n\n\n\n\n\n\nExercise 4\n\n\n\n\nAdd a few section headers to your Quarto document.\nAdd a cross reference to one of the section headers.\n\n\n\n\n\n1.3.2 Figures\n\n\n\nFigure 1.1: Penguins\n\n\nWe can reference figures like Figure 1.1 with @fig-penguins.\n\n\n1.3.3 Tables\nWe can link to tables in our documents. For example, we can link to the greek table with @tbl-greek Table 1.1.\n\n\n1.3.4 Equations\nWe can link to equations in our documents. For example, we can link to the binomial distribution earlier with @eq-binomial Equation 1.1.\n\n\n\n\n\n\nExercise 5\n\n\n\n\nAdd a cross reference to your RMSE equation from earlier."
  },
  {
    "objectID": "01_advanced-quarto.html#citations",
    "href": "01_advanced-quarto.html#citations",
    "title": "1  Advanced Quarto",
    "section": "1.4 Citations",
    "text": "1.4 Citations\n\n1.4.1 Zotero\nZotero is a free and open-source software for organizing research and managing citations.\n\n\n\n\n\n\nDigital Object Identifier (DOI)\n\n\n\nDOIs are persistent identifiers that uniquely identify objects including many academic papers. For example, 10.1198/jcgs.2009.07098 identifies “A Layered Grammar of Graphics” by Hadley Wickham.\n\n\n\n\n\n\n\n\nExercise 6\n\n\n\n\nInstall Zotero.\nFind the DOI for “Tidy Data” by Hadley Wickham.\nClick the magic wand in Zotero and paste the DOI.\n\n\n\n\n\n\n\n\n\n\n\nReview the new entry in Zotero.\n\n\n\n\n\n1.4.2 Zotero Integration\nZotero has a powerful integration with Quarto. In practice, it’s one click to add a DOI to Zotero and then one click to add a citation to Quarto.\nRStudio automatically adds My Library from Zotero. Simply switch to the Visual Editor (top left in RStudio), click “Insert”, and click “Citation”. This will open a prompt to insert a citation into the Quarto document.\nThe citation is automatically added with parentheses to go at the end of sentences. Delete the square brackets to convert the citation to an in-line citation.\nInserting the citation automatically adds the citation to the references section. Deleting the reference automatically deletes the citation from the references section.\nZotero Groups are useful for sharing citations and Zotero Group Libraries need to be added to RStudio. To set this up:\nTo set this up, in RStudio:\n\nGo to Tools and select “Global Options”\nSelect “RMarkdown” and then click “Citations”\nFor “Use Libraries” choose “Selected Libraries”\nSelect the group libraries to add\n\n\n\n\n\n\n\nExercise 7\n\n\n\n\nCite “Tidy Data” by Hadley Wickham in your Quarto document.\nClick “Render”"
  },
  {
    "objectID": "01_advanced-quarto.html#more-resources",
    "href": "01_advanced-quarto.html#more-resources",
    "title": "1  Advanced Quarto",
    "section": "1.5 More Resources",
    "text": "1.5 More Resources\n\nQuarto Guide\nIterating fact sheets and web pages with Quarto"
  },
  {
    "objectID": "01_advanced-quarto.html#footnotes",
    "href": "01_advanced-quarto.html#footnotes",
    "title": "1  Advanced Quarto",
    "section": "",
    "text": "Pandoc is free software that converts documents between markup formats. For example, Pandoc can convert files to and from markdown, LaTeX, jupyter notebook (ipynb), and Microsoft Word (.docx) formats, among many others. You can see a comprehensive list of files Pandoc can convert on their About Page.↩︎\nThis table was typed as Markdown code. But sometimes it is easier to use a code chunk to create and print a table. Pipe any data frame into knitr::kable() to create a table that will be formatted in the output of a rendered Quarto document.↩︎\nThe default dimensions for figures change based on the output format. Visit here to learn more.↩︎\nThe default dimensions for figures change based on the output format. Visit here to learn more.↩︎"
  },
  {
    "objectID": "03_functions.html#sec-review3",
    "href": "03_functions.html#sec-review3",
    "title": "2  Advanced R Programming",
    "section": "2.1 Review",
    "text": "2.1 Review\n\n2.1.1 Relational Data\nWe’ve almost exclusively used data frames up to this point. We leveraged relations within our data to pick subsets of the data with functions like filter().\n\nlibrary(tidyverse)\n\nmsleep |&gt; \n  filter(name == \"Cow\")\n\n# A tibble: 1 × 11\n  name  genus vore  order   conservation sleep_total sleep_rem sleep_cycle awake\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1 Cow   Bos   herbi Artiod… domesticated           4       0.7       0.667    20\n# ℹ 2 more variables: brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;\n\n\nImportantly, we almost never used indices or selected data by position, which can lead to errors if the underlying data change. An example of using indices and selecting data by position would be to pick data from row number 5 and column number 4. This idea of using the relations in data reduces the chances of making mistakes and leads to clearer code."
  },
  {
    "objectID": "03_functions.html#programming",
    "href": "03_functions.html#programming",
    "title": "2  Advanced R Programming",
    "section": "2.2 Programming",
    "text": "2.2 Programming\n\n2.2.1 Selecting Data\nThere are other ways to subset data, which are important when working with objects other than data frames. We will focus on [], [[]], and $.\n\nAtomic Vectors\nMuch of our work focuses on four of the six types of atomic vectors: logical, integer, double, and character. [] is useful for subsetting atomic vectors. Consider a vector with the first six letters of the alphabet:\n\nletters_short &lt;- letters[1:6]\n\nWe can use positive integers to subset to the first and fifth letters of the alphabet.\n\nletters_short[c(1, 5)]\n\n[1] \"a\" \"e\"\n\n\nWe can use negative integers to subset to the everything but the first and fifth letters of the alphabet.\n\nletters_short[c(-1, -5)]\n\n[1] \"b\" \"c\" \"d\" \"f\"\n\n\nWe can use Booleans (trues and falses) to subset to the first and fifth letters of the alphabet.\n\nletters_short[c(TRUE, FALSE, FALSE, FALSE, TRUE, FALSE)]\n\n[1] \"a\" \"e\"\n\n\nThis may seem silly, but we have many ways to create Booleans that we can then use to subset a vector.\n\nbooleans &lt;- letters_short %in% c(\"a\", \"e\")\n\nbooleans\n\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n\nletters_short[booleans]\n\n[1] \"a\" \"e\"\n\n\nWe can use a character vector to subset a named vector.\n\nnamed_vector &lt;- c(a = 1, b = 2, c = 3)\n\nnamed_vector\n\na b c \n1 2 3 \n\nnamed_vector[c(\"a\", \"c\")]\n\na c \n1 3 \n\n\nWe are able to select more than one element with [], which will not be true of [[]] and $. One thing to look out for is vector recycling. Let’s go back to letters_short, which is length six, but consider some indices of varying lengths.\n\nletters_short[TRUE]\n\n[1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\"\n\nletters_short[c(TRUE, FALSE)]\n\n[1] \"a\" \"c\" \"e\"\n\nletters_short[c(TRUE, FALSE, TRUE)]\n\n[1] \"a\" \"c\" \"d\" \"f\"\n\n\n\n\n\n\n\n\nCaution\n\n\n\nWow, R recycles the Booleans. Six is divisible by 1, 2, and 3, so there are many ways to recycle the index to subset letters_short. This is dangerous and can quietly cause analtyic errors.\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\n\nCreate letters_short.\nTry subsetting the vectors with indices with length four or five. What happens?\n\n\n\n\n\nLists\n[[]] and $ are useful for subsetting lists. Both can be used to subset data frames, but I recommending avoiding this.\nUnlike [], which returns multiple elements, [[]] and $ can only return a single element and [[]] and $ simplify objects by removing a layer of hierarchy.\n[[]] can select an element by position or name, while $ can only select an element by name. Consider a list with the first six letters of the alphabet.\n\nalphabet &lt;- list(\n  vowels = c(\"a\", \"e\"),\n  consonants = c(\"b\", \"c\", \"d\", \"f\")\n)\n\nWe can use [] to select the first or second element. In both cases, we get back a smaller list.\n\nalphabet[1]\n\n$vowels\n[1] \"a\" \"e\"\n\nclass(alphabet[1])\n\n[1] \"list\"\n\nalphabet[2]\n\n$consonants\n[1] \"b\" \"c\" \"d\" \"f\"\n\nclass(alphabet[2])\n\n[1] \"list\"\n\n\nWe can use [[]] to select the first or second element. Now, we get back a vector instead of a list. [[]] simplified the object by removing a level of hierarchy.\n\nalphabet[[1]]\n\n[1] \"a\" \"e\"\n\nclass(alphabet[[1]])\n\n[1] \"character\"\n\n\nWe can also use [[]] to select an object by name.\n\nalphabet[[\"vowels\"]]\n\n[1] \"a\" \"e\"\n\nclass(alphabet[[\"vowels\"]])\n\n[1] \"character\"\n\n\nWe can use $ to select either vector by name.\n\nalphabet$vowels\n\n[1] \"a\" \"e\"\n\nclass(alphabet$vowels)\n\n[1] \"character\"\n\n\nReferring to objects by name should make for code that is more robust to changing data.\n\nBeforeAfter\n\n\n\nalphabet1 &lt;- list(\n  vowels = c(\"a\", \"e\"),\n  consonants = c(\"b\", \"c\", \"d\", \"f\")\n)\n\nalphabet1[[2]]\n\n[1] \"b\" \"c\" \"d\" \"f\"\n\nalphabet1[[\"consonants\"]]\n\n[1] \"b\" \"c\" \"d\" \"f\"\n\n\n\n\n\nalphabet2 &lt;- list(\n  vowels = c(\"a\", \"e\"),\n  confusing = \"y\",\n  consonants = c(\"b\", \"c\", \"d\", \"f\")\n)\n\nalphabet2[[2]]\n\n[1] \"y\"\n\nalphabet2[[\"consonants\"]]\n\n[1] \"b\" \"c\" \"d\" \"f\"\n\n\n\n\n\nSubsetting lists can be difficult. Fortunately, RStudio has a tool than can help. Click on a list in your global environment. Navigate to the far right and click the list button with a green arrow. This will generate code and add it to the Console.\n\nInterestingly, this tool avoids $ and uses [[]] to pick the vector by name.\n\nalphabet[[\"vowels\"]]\n\n[1] \"a\" \"e\"\n\n\n\n\n\n2.2.2 Control Flow\n\nFor Loops\nLoops are a fundamental programming tool for iteration; however, they are less common in R than in other programming languages. We previously focused on the Map-Reduce framework and library(purrr) instead of for loops for iteration.\nFor loops have two main pieces: 1. a header and 2. a body. Headers define the number of iterations and potential inputs to the iteration. Bodies are iterated once per iteration. Here is a very simple example:\n\nfor (i in 1:10) {\n  \n  print(i)\n  \n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\nWe can use headers several different ways. Like above, we may just want to repeat the values in the index.\n\nfruit &lt;- c(\"apple\", \"banana\", \"cantelope\")\nfor (b in fruit) {\n  \n  print(b)\n  \n}\n\n[1] \"apple\"\n[1] \"banana\"\n[1] \"cantelope\"\n\n\nWe can use the header as an index.\n\nfruit &lt;- c(\"apple\", \"banana\", \"cantelope\")\nfor (i in 1:3) {\n  \n  print(fruit[i])\n  \n}\n\n[1] \"apple\"\n[1] \"banana\"\n[1] \"cantelope\"\n\n\nWe can leverage the index to use results from previous iterations.\n\nresult &lt;- c(1, NA, NA, NA) \nfor (i in 2:4) {\n  \n  result[i] &lt;- result[i - 1] * 2\n  \n}\n\nresult\n\n[1] 1 2 4 8\n\n\nWe’ve now seen three different ways to use the header.\n\nSimply repeat the elements in the header (e.g. print i).\nUse the elements in the header as an index (e.g. select the \\(i^{th}\\) element).\nUse the header to reference past iterations (e.g. i - 1)\n\n\n\n\n\n\n\nDon’t grow vectors!\n\n\n\nIt is tempting to initialize a vector and then grow the vector with a for loop and c(). It is also tempting to initialize a data frame and then grow the data frame with bind_rows(). Because of R’s design, this is computationally very inefficient.\nThis is slow!:\n\nvec &lt;- c(1)\n\nfor (i in 2:10) {\n  \n  vec &lt;- c(vec, i)\n  \n  \n}\n\nvec\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\nIt is essential to pre-allocate vectors and then fill them in. It is also easy to make mistakes when creating indices (e.g. 1:length(x) may end up as c(1, 0)). seq_along() is a helpful alternative to :. The following pre-allocates a vector and then uses the length of the vector to create an index.\n\nnumbers &lt;- vector(mode = \"numeric\", length = 5)\n\nnumbers\n\n[1] 0 0 0 0 0\n\nfor (i in seq_along(numbers)) {\n  \n  numbers[i] &lt;- i\n  \n}\n\nnumbers\n\n[1] 1 2 3 4 5\n\n\nLet’s consider a simple random walk with 100 steps. In this case, the person starts at location zero and random takes one step forward or one step back.\n\nposition &lt;- vector(mode = \"numeric\", length = 100)\n\nset.seed(20230530)\nfor (iter in 2:length(position)) {\n  \n  position[iter] &lt;- position[iter - 1] + sample(x = c(-1, 1), size = 1)\n  \n  \n}\n\nposition\n\n  [1]  0 -1  0  1  2  1  0  1  0  1  2  1  0  1  2  1  2  1  2  1  2  1  2  1  2\n [26]  3  4  5  4  3  2  3  4  3  4  3  2  3  2  3  2  3  2  3  2  3  2  1  2  3\n [51]  2  3  4  3  4  5  6  5  6  5  6  7  6  5  6  7  8  9 10 11 12 13 12 13 12\n [76] 11 10  9 10  9  8  9 10 11 12 13 12 11 12 11 12 13 12 13 14 15 14 15 14 15\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\n\nCreate the following list:\n\n\nalphabet &lt;- list(\n  vowels = c(\"a\", \"e\"),\n  confusing = \"y\",\n  consonants = c(\"b\", \"c\", \"d\", \"f\")\n)\n\n\nWrite a for loop and use str_to_upper() to transform all letters to upper case.\n\n\n\n\n\nWhile Loops\nWhile loops are similar to for loops; however, instead of predetermining the number of iterations in the header, while loops determine a condition in the header and run until that condition is met. For loops can be rewritten as while loops. It can be useful to track the iteration number. Consider a simple example where we double x every iteration while x &lt; 1000.\n\niteration &lt;- 1\nx &lt;- 2\n\nwhile (x &lt; 1000) {\n  \n  x &lt;- x * 2\n  iteration &lt;- iteration + 1\n  \n}\n\nx \n\n[1] 1024\n\niteration\n\n[1] 10\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\n\nWrite the random walk from the for loop above as a while loop. Stop the while loop when position &lt; -10 or position &gt; 10. How many iterations did it take?\n\n\n\n\n\nif, else, and else if\nif_else() and case_when() apply conditional logic to a vector. We most frequently use those functions inside of mutate() to create a new variable or manipulate an existing variable.\nR also has if, else, and else if, which are used to select sections of code to run. This is incredibly useful when programming outside of data manipulation. For example, we can use if to download a file only if it doesn’t already exist.\n\nif (!file.exists(\"data.csv\")) {\n\n  download.file(url = \"web-url.csv\", destfile = \"data.csv\")\n\n}\n\nSelection control flow has two important pieces. First, there is a conditional statement inside (). If the condition is TRUE, then evaluate. If it is FALSE, then don’t evaluate. Second, there is a body contained in {}. Note the formatting in the above example.\nThe conditional statement must be a single TRUE or FALSE. If your statement involves more than one Boolean, then consider using all(), which evaluates to TRUE if everything is TRUE and any(), which evaluates to TRUE if anay element is TRUE.\nLet’s consider a more sophisticated example.\n\nif (distribution == \"normal\") {\n  \n  x &lt;- rnorm(n = 100)\n  \n} else if (distribution == \"poisson\") {\n  \n  x &lt;- rpois(n = 100, lambda = 8)\n  \n} else {\n  \n  stop(\"distribution mast be normal or poissoin\")\n  \n}\n\nThis style of using if, else if, and else is fundamental for including options in custom functions."
  },
  {
    "objectID": "03_functions.html#custom-functions",
    "href": "03_functions.html#custom-functions",
    "title": "2  Advanced R Programming",
    "section": "2.3 Custom Functions",
    "text": "2.3 Custom Functions\n\n2.3.1 Motivation\nCustom functions are an essential building block for good analyses. Custom functions are useful for abiding by the DRY (don’t repeat yourself) principle. Under our conception of DRY, we should create a function any time we do something three times.\nCopying-and-pasting is typically bad because it is easy to make mistakes and we typically want a single source source of truth in a script. Custom functions also promote modular code design and testing.\nThe bottom line: we want to write clear functions that do one and only one thing that are sufficiently tested so we are confident in their correctness.\n\n\n2.3.2 Examples\nLet’s consider a couple of examples from (Barrientos et al. 2021). This paper is a large-scale simulation of formally private mechanisms, which relates to several future chapters of this book.\nDivision by zero, which returns NaN, can be a real pain when comparing confidential and noisy results when the confidential value is zero. This function simply returns 0 when the denominator is 0.\n\n#' Safely divide number. When zero is in the denominator, return 0. \n#'\n#' @param numerator A numeric value for the numerator\n#' @param denominator A numeric value for the denominator\n#'\n#' @return A numeric ratio\n#'\nsafe_divide &lt;- function(numerator, denominator) {\n  \n  if (den == 0) {\n    \n    return(0)\n    \n  } else {\n    \n    return(num / denom)\n    \n  }\n}\n\nThis function\n\nImplements the laplace or double exponential distribution, which isn’t included in base R.\nApplies a technique called the laplace mechanism.\n\n\n#' Apply the laplace mechanism\n#'\n#' @param eps Numeric epsilon privacy parameter\n#' @param gs Numeric global sensitivity for the statistics of interest\n#'\n#' @return\n#' \nlap_mech &lt;- function(eps, gs) {\n  \n  # Checking for proper values\n  if (any(eps &lt;= 0)) {\n    stop(\"The eps must be positive.\")\n  }\n  if (any(gs &lt;= 0)) {\n    stop(\"The GS must be positive.\")\n  }\n  \n  # Calculating the scale\n  scale &lt;- gs / eps\n\n  r &lt;- runif(1)\n\n  if(r &gt; 0.5) {\n    r2 &lt;- 1 - r\n    x &lt;- 0 - sign(r - 0.5) * scale * log(2 * r2)\n  } else {\n    x &lt;- 0 - sign(r - 0.5) * scale * log(2 * r)\n  }\n  \n  return(x)\n}\n\n\n\n2.3.3 Basics\nR has a robust system for creating custom functions. To create a custom function, use function():\n\nsay_hello &lt;- function() {\n  \n  \"hello\"\n   \n}\n\nsay_hello()\n\n[1] \"hello\"\n\n\nOftentimes, we want to pass parameters/arguments to our functions:\n\nsay_hello &lt;- function(name) {\n  \n  paste(\"hello,\", name)\n   \n}\n\nsay_hello(name = \"aaron\")\n\n[1] \"hello, aaron\"\n\n\nWe can also specify default values for parameters/arguments:\n\nsay_hello &lt;- function(name = \"aaron\") {\n  \n  paste(\"hello,\", name)\n   \n}\n\nsay_hello()\n\n[1] \"hello, aaron\"\n\nsay_hello(name = \"alex\")\n\n[1] \"hello, alex\"\n\n\nsay_hello() just prints something to the console. More often, we want to perform a bunch of operations and the then return some object like a vector or a data frame. By default, R will return the last unassigned object in a custom function. It isn’t required, but it is good practice to wrap the object to return in return().\nIt’s also good practice to document functions. With your cursor inside of a function, go Insert &gt; Insert Roxygen Skeleton:\n\n#' Say hello\n#'\n#' @param name A character vector with names\n#'\n#' @return A character vector with greetings to name\n#' \nsay_hello &lt;- function(name = \"aaron\") {\n  \n  greeting &lt;- paste(\"hello,\", name)\n  \n  return(greeting)\n  \n}\n\nsay_hello()\n\n[1] \"hello, aaron\"\n\n\nAs you can see from the Roxygen Skeleton template above, function documentation should contain the following:\n\nA description of what the function does\nA description of each function argument, including the class of the argument (e.g. string, integer, dataframe)\nA description of what the function returns, including the class of the object\n\nTips for writing functions:\n\nFunction names should be short but effectively describe what the function does. Function names should generally be verbs while function arguments should be nouns. See the Tidyverse style guide for more details on function naming and style.\nAs a general principle, functions should each do only one task. This makes it much easier to debug your code and reuse functions!\nUse :: (e.g. dplyr::filter()) when writing custom functions. This will create stabler code and make it easier to develop R packages.\n\n\n\n2.3.4 Functions with Multiple Outputs\nWhen return() is reached in a function, return() is evaluated and evaluation ends and R leaves the function.\n\nsow_return &lt;- function() {\n  \n  return(\"The function stops!\")\n  \n  return(\"This never happens!\")\n  \n}\n\nsow_return()\n\n[1] \"The function stops!\"\n\n\nIf the end of a function is reached without calling return(), the value from the last evaluated expression is returned.\nWe prefer to include return() at the end of functions for clarity even though return() doesn’t change the behavior of the function.\nSometimes we want to return more than one vector or data frame. list() is very helpful in these siutations.\n\nsummarize_results &lt;- function(x) {\n  \n  mean_x &lt;- mean(x)\n  \n  median_x &lt;- median(x)\n  \n  results &lt;- list(\n    mean = mean_x,\n    median = median_x\n  )\n  \n  return(results)\n  \n}\n\nsummarize_results(x = 1:10)\n\n$mean\n[1] 5.5\n\n$median\n[1] 5.5\n\n\n\n\n2.3.5 Referential Transparency\nR functions, like mathematical functions, should always return the exact same output for a given set of inputs1. This is called referential transparency. R will not enforce this idea, so you must write good code.\n\nBad!\n\nbad_function &lt;- function(x) {\n  \n  x * y\n  \n}\n\ny &lt;- 2\nbad_function(x = 2)\n\n[1] 4\n\ny &lt;- 3\nbad_function(x = 2)\n\n[1] 6\n\n\n\n\nGood!\n\ngood_function &lt;- function(x, y) {\n  \n  x * y\n  \n}\n  \ny &lt;- 2\ngood_function(x = 2, y = 1)\n\n[1] 2\n\ny &lt;- 3\ngood_function(x = 2, y = 1)\n\n[1] 2\n\n\nBruno Rodriguez has a book and a blog that explores this idea further."
  },
  {
    "objectID": "03_functions.html#debugging",
    "href": "03_functions.html#debugging",
    "title": "2  Advanced R Programming",
    "section": "2.4 Debugging",
    "text": "2.4 Debugging\nR code inside of custom functions can be tougher to troubleshoot than R code outside of custom functions. Fortunately, R has a powerful debugging tool.\nThe debugger requires putting custom functions in their own scripts. This is covered in Section 2.6.\nTo set up the debugger, simply select the red dot to the left of a line of code in a custom function and then source the custom function. After, there should be a red dot next to the defined function in the global environment.2\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n(b)\n\n\n\n\nFigure 2.1: Setting up the debugger\n\n\nNow, when the function is called it will stop at the red dot (the stop point). Importantly, the environment should reflect the environment inside of the function instead of the global environment.\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n(b)\n\n\n\n\nFigure 2.2: Using the debugger\n\n\nFinally, RStudio gives several controls for the debugger. There is a button to Continue to the end of the function. There is a button to Stop execution.\nThere is also a button with two brackets and a green arrow. This steps the debugger into another function. This is incredibly useful when functions are nested inside of functions.\n\n\n\n\n\n\n\nExercise 4\n\n\n\n\nCreate a custom function with at least three different pieces of R code.\nSave the function in a .R script with the same name as the function.\nClick the little red dot to the left of first line of code in the .R script.\nSource the function with the source button at the top right.\nCall the function. You should enter the debugger."
  },
  {
    "objectID": "03_functions.html#benchmarking",
    "href": "03_functions.html#benchmarking",
    "title": "2  Advanced R Programming",
    "section": "2.5 Benchmarking",
    "text": "2.5 Benchmarking\nBenchmarking is the process of estimating the run time of code. Oftentimes, benchmarking is used to compare multiple pieces of code to pick the more performant code. This raises a couple of issues:\n\nComputing environments differ. My MacBook Pro with Apple M1 chips typically outperforms my work computer.\nOther software can slow performance. When I open up Spotify my R processes typically slow down.\n\nWe can’t solve problem 1 with an R package, but we can solve problem 2 by running tests multiple times. library(microbenchmark) makes this very easy.\nSuppose we are interested in the median of a vector of 1 million numbers. We can easily calculate this with median() or quantile(). Suppose we are concerned about computation speed, so lets test the code performance:\n\nlibrary(microbenchmark)\n\nx &lt;- 1:1000000\n\nmicrobenchmark::microbenchmark(\n  median(x),\n  quantile(x, probs = 0.5)\n)\n\nWarning in microbenchmark::microbenchmark(median(x), quantile(x, probs = 0.5)):\nless accurate nanosecond times to avoid potential integer overflows\n\n\nUnit: milliseconds\n                     expr      min       lq     mean   median      uq       max\n                median(x) 5.910601 6.361847 7.220074 6.445712 7.45460 42.729995\n quantile(x, probs = 0.5) 3.300992 3.600989 4.098829 3.659311 4.14061  8.473224\n neval\n   100\n   100\n\n\n\n\n\n\n\n\nExercise 5\n\n\n\nLet’s compare %&gt;% and |&gt; to see if they have comparable computation times. Consider this example from Stack Overflow, which shows |&gt; is clearly better.\n\nLoad library(microbenchmark) and add the microbenchmark() function.\nCreate x1 &lt;- 1:1000000, x2 &lt;- 1:1000000, and x3 &lt;- 1:1000000\nTest median(x1), x2 |&gt; median(), and x3 %&gt;% median().3"
  },
  {
    "objectID": "03_functions.html#sec-organizing-an-analysis",
    "href": "03_functions.html#sec-organizing-an-analysis",
    "title": "2  Advanced R Programming",
    "section": "2.6 Organizing an Analysis",
    "text": "2.6 Organizing an Analysis\nWe recommend writing functions for data analysis. We need a plan for how to add custom functions to our workflow built on RStudio projects and Quarto.\nWe typically recommending adding a directory called R or src in a project directory and then sourcing scripts in to Quarto documents. Keeping functions in separate scripts makes the functions easier to use in multiple documents and simplifies the debugging process outlined above.\nWe typically only add one function to an R script in the R/ directory and name the script after the function (without parentheses). Next, we source function scripts at the top of Quarto documents after loading packages with the source(). library(here) is essential if when sourcing from a Quarto document that is in a subdirectory of the project."
  },
  {
    "objectID": "03_functions.html#packages",
    "href": "03_functions.html#packages",
    "title": "2  Advanced R Programming",
    "section": "2.7 Packages",
    "text": "2.7 Packages\nAt some point, the same scripts or data are used often enough or widely enough to justify moving from sourced R scripts to a full-blown R package. R packages make it easier to\n\nMake it easier to share and version code.\nImprove documentation of functions and data.\nMake it easier to test code.\nOften lead to fun hex stickers.\n\n\n2.7.1 Use This\nlibrary(usethis) includes an R package template. The following will add all necessary files for an R package to a directory called testpackage/ and open an RStudio package.\n\nlibrary(usethis)\ncreate_package(\"/Users/adam/testpackage\")\n\n\n\n2.7.2 Package contents\nThe template includes a lot of different files and directories. We will focus on the minimum sufficient set of files for building a package.\nDESCRIPTION contains the meta information about the package. Important lines include the package version and the license. Package versions are useful for tracking the version of the package used with an analysis. library(usethis) has a helper function for picking a license.\nPackage: testpackage\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"First\", \"Last\", , \"first.last@example.com\", role = c(\"aut\", \"cre\"),\n           comment = c(ORCID = \"YOUR-ORCID-ID\"))\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n\n\n2.7.3 Functions\nFunctions go in the R directory, just like when we sourced functions earlier. Be sure to reference packages directly with :: (e.g. stats::lm()).\n\nRoxygen\nIt is essential to use Roxygen skeletons with custom functions. RStudio makes this simple. Place the cursor in a function and select Code &gt; Insert Roxygen Skeleton. The Roxygen skeleton creates help documentation for a package, which can be accessed with ?.\n#' Title\n#'\n#' @param\n#'\n#' @return\n#' @export\n#'\n#' @examples\nThe title should be a brief description of the function. param describes each input to the function and return describes the output of the function.\n\n\nTests"
  },
  {
    "objectID": "03_functions.html#unit-testing",
    "href": "03_functions.html#unit-testing",
    "title": "2  Advanced R Programming",
    "section": "2.8 Unit testing",
    "text": "2.8 Unit testing\nUnit testing is the systematic testing of functions to ensure correctness."
  },
  {
    "objectID": "03_functions.html#test-coverage",
    "href": "03_functions.html#test-coverage",
    "title": "2  Advanced R Programming",
    "section": "2.9 Test coverage",
    "text": "2.9 Test coverage\nTest coverage is the scope and quality of tests performed on a code base."
  },
  {
    "objectID": "03_functions.html#references",
    "href": "03_functions.html#references",
    "title": "2  Advanced R Programming",
    "section": "2.10 References",
    "text": "2.10 References\n\n\n\n\nBarrientos, Andrés F., Aaron R. Williams, Joshua Snoke, and Claire McKay Bowen. 2021. “A Feasibility Study of Differentially Private Summary Statistics and Regression Analyses with Evaluations on Administrative and Survey Data.” https://doi.org/10.48550/ARXIV.2110.12055."
  },
  {
    "objectID": "03_functions.html#footnotes",
    "href": "03_functions.html#footnotes",
    "title": "2  Advanced R Programming",
    "section": "",
    "text": "This rule won’t exactly hold if the function contains random or stochastic code. In those cases, the function should return the same output every time if the seed is set with set.seed().↩︎\nAccording to Hadley Wickham, “You can think of an environment as a bag of names. Each name points to an object stored elsewhere in memory.” For more details, see the Environments chapter of Advanced R.↩︎\nDon’t be surprised when microbenchmark::microbenchmark() returns a row with expr median(x2) instead of x2 |&gt; median(). This is expected behavior because the base pipe is implemented as a syntax transformation. You can read more about this in this blog.↩︎"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Barrientos, Andrés F., Aaron R. Williams, Joshua Snoke, and Claire McKay\nBowen. 2021. “A Feasibility Study of Differentially Private\nSummary Statistics and Regression Analyses with Evaluations on\nAdministrative and Survey Data.” https://doi.org/10.48550/ARXIV.2110.12055."
  }
]